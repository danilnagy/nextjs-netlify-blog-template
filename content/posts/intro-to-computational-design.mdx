---
slug: intro-to-computational-design
title: Intro to Computational Design
date: 2022-12-01
author: daniln
tags:
  - grasshopper
  - beginner
next: /posts/intro-to-computational-design
roles:
nextRoles:
---

## Computers in design

Computers have been impacting the way designers work since the arrival of the personal computer in the early 1980s. These days, computers are heavily integrated into the day-to-day work of almost every design professional. However, most designers still rely on out-of-the-box software solutions that come with standard user interfaces that support typical workflows for accomplishing specific design tasks.

![description](/images/4-1-2.png)

Recently, however, a growing number of designers are going a level deeper to actually program computers to do more specialized tasks and leveraging the power of algorithms and computation to unlock new potentials for their creative design work.

When we talk about computational design, we’re usually referring to using a computer beyond the standard workflow created by a particular software. Traditional software is controlled through a visual user interface (UI) composed of elements such as buttons and text boxes which allow the user to perform a set of pre-defined tasks. Meanwhile, the core functionality of the software is hidden away from the user.

Computational design tools give users access to these core functionalities, allowing them to control the software directly through custom programs and algorithms. To build these algorithms, computational designers must be familiar with some level of computer programming, which is the practice of writing algorithms to describe specific tasks to a computer. Although computer programming is not traditionally thought of as a core design skill, as design workflows become more and more digital and complex, the ability to program design tools to do custom things is becoming increasingly important.

## What is computational design for?

Computational design is still an emerging field, with many new uses emerging every day. Some of the more common uses are:

### Parametric design

When you describe a design as a system rather than a static object, you can expose certain variables or parameters that control how the system works. Later, you can adjust these parameters to quickly change the design outcome without having to rebuild the entire model. For example, if you modeled a curtain wall the traditional way and the panel design changed, you would have to rebuild the entire model with the new design. But, if you described the process of creating the curtain wall using computational design (for example, take a single panel model and align it with a grid of points generated according to the dimensions of the building), you would simply input the new panel design and run the program again to regenerate the entire model automatically.

![description](/images/4-1-3.jpeg)

### Formal complexity

Creating a computational design system can be challenging and time-consuming, but once the system is defined you can easy run it many times to create a large amount of geometry and complexity, often much more than would be possible to model or develop by hand. The capability of computational design tools to generate an extreme level of variation within a given system was expressed strongly in the visual language of many architectural projects of the 2000’s when these tools first started to become available. While this kind of computationally-driven formal variation is still popular, the emphasis these days is more on how to make it buildable by tapping into similarly-sophisticated fabrication workflows.

![description](/images/4-1-4.jpeg)

### Performance-driven design

Another major advantage of computational design is that it allows the designer to easily connect their design models to computer simulation tools that can help them evaluate the performance of their designs (for example structural, environmental, or energy performance). Traditionally, each time a designer wanted to perform a simulation they would have to process their digital model manually for each specific simulation program. With computational design, the design is already defined through data, making it much easier to connect to simulation engines that run within the same computational design environment. This creates more immediate feedback and a much faster turnaround, allowing simulations to be used much earlier in the design process.

![description](/images/4-1-5.png)

### Design automation

Because of it’s focus on breaking down and describing design processes, computational design can be used to build custom tools and workflows that automate some portions of the design processes. This can range from simple definitions that automatically add tags to particular objects in a model, to complex [optimization workflows](/posts/design-optimization) that can actually help the designer find optimal solutions to their problems given a set of high-level objectives..

![description](/images/4-1-6.png)

## How do we do computational design?

Computational design reframe the designer’s task from the design of a single physical object with a fixed form, to the design of systems which encode a range of formal possibilities for a particular design concept. Unfortunately, the software tools traditionally used by architects cannot do this because they represent design in a static way. They typically provide a digital 3d environment and a set of modelling tools with which designers can craft singular design solutions as static representations of physical forms.

To define dynamic design space models, we need a different kind of design tool. Instead of specifying a single static form, we need to define the process by which a design is created. With this process description, we can then go back and tweak the individual steps to create different designs.

One way to do this would be to have the design software actually remembered every step that we took to achieve a final design, and then allow us to go back, change some intermediate condition, and then play the whole process out again from that point. In fact, the Rhino modelling software has a feature called Record History that does exactly this. In practice, however, this type of direct recording of operations tends to be messy and opaque, and does not allow us to be explicit in how we define our system or how we abstract the input parameters of the design space.

What we need is a separate design environment, abstracted from the representation of physical geometry, which would allow us to explicitly encode a set of steps or instructions for how the design should be generated. In computer terminology, a set of instructions is called an algorithm. Thus we can call the process of designing through a set of instructions algorithmic design. In practice such a design process is also referred to as parametric design, or more generally computational design.

### Tools for computational design

This class will teach computational design strategies using the Python programming language. However, instead of starting from scratch, we will write the code inside another computational framework — Rhino’s Grasshopper. This is a different kind of programming environment called a visual scripting language. Instead of individual lines of code, Grasshopper uses a collection of visual nodes to represent operations in the model, with connections between the nodes specifying how data flows between the operations. Grasshopper has become very popular for computational design in architecture because it is initially much more intuitive and easier to learn than actual code (you can think of it as another example of a user interface abstracting the complexities of computer code for the human user).

Because of its simplicity and popularity, Grasshopper is a great place to start building our design space models. In the next section we will spend some time describing the Grasshopper system and show some examples of how it can be used to create parametric models.